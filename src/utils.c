/*-------------------------------------------------------------------------------------------------/
 *  Utils functions for a C- Compiler
 *  File: utils.c
 *---------------------------------*/

#define _DEFAULT_SOURCE

#include "utils.h"
#include "globals.h"
#include "parser.tab.h"

char source[512];

#define MAX_FILES 100
#define MAX_NAME 256

/*--------------------------------------------/
 *  Indentation and Design functions
 *---------------------------------*/

void newLine(void) {
    printf("\n");
}

void printBars(void) {
    printf("\n------------------------------------------------------------------------\n");
}

void printSpace(void) {
    printf(" ");
}

/*--------------------------------------------/
 *  Utility functions
 *---------------------------------*/

/*  inputSelect() → Searches for the input folder provided and lists the files, allowing you to select one to use   */
void inputSelect(void) {
    char files[MAX_FILES][MAX_NAME];
    int count = 0;

    newLine();

    const char* folder = INPUT_DIR;
    DIR *dir = opendir(folder);
    if (!dir) {
        perror("> Misc Error\n     Could not find the desired folder.\n");
        exit(EXIT_FAILURE);
    }

    struct dirent *entry;
    printf("> Files available at \"%s\":\n", folder);

    while ((entry = readdir(dir)) != NULL) {
        if (entry->d_type == DT_REG) {
            printf("[%d] %s\n", count, entry->d_name);
            strncpy(files[count], entry->d_name, MAX_NAME);
            count++;
        }
    }
    closedir(dir);

    if (count == 0) {
        printf("> Misc Error\n     No files found.\n");
        exit(EXIT_FAILURE);
    }

    newLine();

    int choice;
    printf("> Enter the desired file number: ");
    scanf("%d", &choice);

    if (choice < 0 || choice >= count) {
        printf("> Misc Error\n     Invalid choice.\n");
        exit(EXIT_FAILURE);
    }

    snprintf(source, sizeof(source), "%s/%s", folder, files[choice]);
    yyin = fopen(source, "r");

    if (!yyin) {
        perror("> Misc Error\n     Invalid file.\n");
        exit(EXIT_FAILURE);
    }
 }

/*  tokenToString() → Transforms a numeric token into a string token based on the table generated by the parser (YACC-Bison)   */
const char* tokenToString(int token) {
    switch (token) {
        case INT: return "INT";
        case VOID: return "VOID";

        case IF: return "IF";
        case ELSE: return "ELSE";
        case WHILE: return "WHILE";
        case RETURN: return "RETURN";

        case SUM: return "SUM";
        case SUB: return "SUB";
        case MUL: return "MUL";
        case DIV: return "DIV";

        case GET: return "GET";
        case MORE: return "MORE";
        case LESS: return "LESS";
        case EQUALMORE: return "EQUALMORE";
        case EQUALLESS: return "EQUALLESS";
        case EQUAL: return "EQUAL";
        case DIFER: return "DIFER";

        case COMMA: return "COMMA";
        case SEMI: return "SEMI";

        case OPARENTHESIS: return "OPARENTHESIS";
        case CPARENTHESIS: return "CPARENTHESIS";
        case OBRACKETS: return "OBRACKETS";
        case CBRACKETS: return "CBRACKETS";
        case OKEYS: return "OKEYS";
        case CKEYS: return "CKEYS";

        case NUM: return "NUM";
        case ID: return "ID";

        case 0: return "EOF";

        default: return "UNKNOWN";
    }
 }

/*--------------------------------------------/
 *  Abstract Syntax Tree (AST) functions
 *---------------------------------*/

TreeNode *newDeclNode(DeclKind kind) {
    TreeNode *t = (TreeNode *)malloc(sizeof(TreeNode));

    if (t == NULL) {
        printf("> Misc Error\n   Line %d - Out of memory error. (Declaration Node)\n", yylineno);
    } else {
        for (int i = 0; i < MAXCHILDREN; i++) t->child[i] = NULL;
        t->sibling = NULL;
        
        t->lineno = yylineno;

        t->nodekind = DeclarationK;
        t->kind.decl = kind;

        // t->type = -1;
    }
    return t;
}

TreeNode *newStmtNode(StmtKind kind) {
    TreeNode *t = (TreeNode *)malloc(sizeof(TreeNode));

    if (t == NULL) {
        printf("> Misc Error\n   Line %d - Out of memory error. (Statement Node)\n", yylineno);
    } else {
        for (int i = 0; i < MAXCHILDREN; i++) t->child[i] = NULL;
        t->sibling = NULL;
        
        t->lineno = yylineno;

        t->nodekind = StatementK;
        t->kind.stmt = kind;

        // t->type = -1;
    }
    return t;
}

TreeNode *newExpNode(ExpKind kind) {
    TreeNode *t = (TreeNode *)malloc(sizeof(TreeNode));

    if (t == NULL) {
        printf("> Misc Error\n   Line %d - Out of memory error. (Expression Node)\n", yylineno);
    } else {
        for (int i = 0; i < MAXCHILDREN; i++) t->child[i] = NULL;
        t->sibling = NULL;
        
        t->lineno = yylineno;

        t->nodekind = ExpressionK;
        t->kind.exp = kind;

        // t->type = -1;
    }
    return t;
}

TreeNode *addSibling(TreeNode *t, TreeNode *sibling) {
    if (t == NULL) return sibling;
    
    TreeNode *current = t;

    while (current->sibling != NULL)
        current = current->sibling;
    current->sibling = sibling;
    
    return t;
}

void printTree(TreeNode *tree) {
    printf("\n--- TESTING AST PRINTING ---\n");
}